#### 2.2 运行时数据区域

 线程隔离：程序计数器 本地方法栈 虚拟机栈
 线程共享：方法区 堆内存 执行引擎 本地库接口-> 本地方法库

##### 2.2.1 程序计数器(线程私有)：

1. 当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器、分支、循环、跳转、异常处理、线程恢复都依赖程序计数器(执行java方法 计数器记录的是正在执行的虚拟机字节码指令的地址)。

##### 2.2.2 虚拟机栈(线程私有 OOM错误和SOF错误)：

1. 描述的是java方法执行的线程内存模型，每个方法执行时，java虚拟机会同步产生一个栈针(stack frame，用于存储局部变量表、操作数栈、动态链接、方法出口),方法的调用和执行对应栈针的入栈和出栈。
   - 1.1局部变量表，存放java基础数据类型以及对象引用(指向对象起始地址的引用指针或者代表对象的句柄或者此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。

##### 2.2.3 本地方法栈(线程私有)：

1. 和虚拟机栈相似，虚拟机栈为java方法(字节码)服务，本地方法栈是为虚拟机使用到的本地方法服务(native方法)。

##### 2.2.4 java堆内存(线程共享，OOM错误)： 

1. 几乎(即时编译，逃逸技术，栈上分配和标量替换的优化手段)所有的对象实例都在堆内存中分配，java堆是垃圾收集器(GC)管理的内存区域，堆内存可以划分多个线程私有的分配缓冲区以提高对象分配的效率，更好的回收内存，堆内存可以处于物理上不连续的内存空间(大对象为了实现简单，存储高效还是会采用连续的内存空间)。

##### 2.2.5 方法区(线程共享，OOM错误，1.8完全移除，元空间metaspace代替)：

1. 存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存，GC可以同管理堆一样管理方法去，回收目标主要是常量池和对类型的卸载。
   - 1.1 **为什么别名永久代**，因为hotspot团队把收集器的分代设计扩展至方法区，或者说使用永久代实现方法区，不需要连续的内存以及可以选择固定大小和可扩展，还可以不实现垃圾收集，垃圾收集行为在这个区域较少出现。

##### 2.2.6 运行中的常量池(方法区的一部分，OOM错误)：

1. CLASS文件中除了有类的版本、字段、方法、接口描述信息外还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，在类加载后存放到方法区的运行时常量池中，除了保存Class文件中描述的符号引用外，还会把符号引用翻译出来的直接引用也存储再运行时的常量池中。运行中的常量池具备动态特性，可以在程序运行期间也可以将新的常量放入池中(例如String的intern()方法可以将字符串存放至常量池中)

##### 2.2.7 直接内存(OOM错误)：

1. 不是虚拟机运行时数据区的一部分，例如NIO使用Native函数库直接分配堆外内存，通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，可以提高性能，避免在java堆中和Native堆中来回复制数据。

---



#### 2.3.1 对象的创建

##### 2.3.1.1 类加载检查 

1. jvm收到new指令，首先检查这个指令的参数是否在能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过，如果没有需要先执行相应的类加载过程。

##### 2.3.1.2 新对象分配内存

1. 类加载检查通过后为新对象分配内存，所需大小在类加载完成后便可确定，其中分配内存有两种方式，选择那种分配方式由java堆是否规整决定，java堆是否规整由所采用的垃圾收集器是否带有空间压缩整理能力决定，因此当使用Serial和ParNew带压缩整理过程的收集器时，系统采用指针碰撞，既简单又高效；当使用CMS这种基于清除(Sweep)算法的收集器时，理论上只能采用较为复杂的空闲列表来分配内存。

- 1.1指针碰撞 假设java堆中的内存是绝对规整的，使用过的内存和空闲的内存被划分为两个区域，中间放着一个指针作为分界点的指示器，那么分配内存就是把指针向空闲空间方向挪动一段与对象大小相等的距离。

- 1.2 空闲列表 如果java堆中的内存不是规整的，虚拟机维护了一个列表，记录哪块内存是可用的，在分配时从列表中找到一块足够大的空间划分给对象实例，并且更新列表上的记录。
- 1.3 分配内存(指针修改)的线程安全
  - 1.3.1 CAS(乐观锁)+失败重试的方式保证更新操作的原子性。
  - 1.3.2 TLAB 把内存分配动作按照线程划分在不同的空间中进行，即每一个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)，那个线程需要分配内存就在当前线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

##### 2.3.1.3 初始化零值

1. JVM将分配到的内存空间(不包括对象头)都初始化零值，如果使用了TLAB，可在TLAB分配时顺便进行。这步操作保证了对象实例字段再java代码中可以不赋初值直接使用，使程序能访问到这些字段的数据类型所对应的零值。

##### 2.3.1.4 设置对象头信息

1. JVM对对象进行必要的设置 例如这个对象是那个类的实例，如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。根据虚拟机当前运行状态的不同，如是否启用偏向锁，对象头会有不同的设置方式。

##### 2.3.1.5 执行init方法(构造函数方法)

1. 执行init方法(构造函数方法)new指令之后会接着执行init方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

---



#### 2.3.2 对象的内存布局
在虚拟机中，对象在堆内存中的存储布局可以划分为三个部分： 对象头(Header)、 实例数据(Instance Data)和对齐填充(Padding)。
##### 2.3.2.1 对象头

1. 存储对象自身的运行时数据(哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳)，这部分数据的长度为32位和64位的虚拟机(未开启压缩指针)中分别为32byte和64byte，称为("Mark Word")
2. 对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，虚拟机通过这个指针来确定该对象是哪个类的实例，如果对象是一个java数组，那么对象头中还必须有一块用于记录数组长度的数据。

  ##### 2.3.2.2 实例数据
1. 实例数据部分是对象真正存储的有效信息，即程序代码里面所定义的各种类型的字段内容，顺序受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响，相同宽度的字段总是被分配到一起存放。

##### 2.3.2.3 对齐填充

1. 并不是必须存在，也没有特别含义，起着占位符的作用。虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是任何对象的大小都必须是8字节的整数倍。如果对象实例数据部分没有对齐的话，需要通过对齐补充来补全。

---



#### 2.3.3 对象的访问定位

##### 2.3.3.1 句柄：

1.  java堆中将可能会划出一块内存来作为句柄池，reference(栈)中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。![1621489403971](C:\Users\陈俊杰的小可爱\AppData\Roaming\Typora\typora-user-images\1621489403971.png)

##### 2.3.3.2 直接指针 ：

1. java堆中对象内存布局就必须考虑如何放置访问类型的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。![1621489425807](C:\Users\陈俊杰的小可爱\AppData\Roaming\Typora\typora-user-images\1621489425807.png)

##### 2.3.3.3 总结:：

1. 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普通的行为)是只会改变句柄的实例数据指针，而reference本身不需要修改，使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在java中非常频繁，因此这类开销积少成多也是一项极为可观的成本。HotSpot主要使用直接指针(如果使用shenandoah收集器也会有一次额外的转发)。

---



#### 2.4 OOM错误



